1630317969031:(defn divisible-by? [x y] (zero? (mod x y)))
1630318017569:(let [x 5]\n  (cond (divisible-by? x 15) :fizz-buzz\n        (divisible-by? x 5)  :buzz\n        (divisible-by? x 3) :fizz\n        x))
1630318022214:(let [x 5]\n  (cond (divisible-by? x 15) :fizz-buzz\n        (divisible-by? x 5)  :buzz\n        (divisible-by? x 3) :fizz\n        :else x))
1630318030198:(let [x 15]\n  (cond (divisible-by? x 15) :fizz-buzz\n        (divisible-by? x 5)  :buzz\n        (divisible-by? x 3) :fizz\n        :else x))
1630318044391:(macroexpand\n  '(cond (divisible-by? x 15) :fizz-buzz\n        (divisible-by? x 5)  :buzz\n        (divisible-by? x 3) :fizz\n        :else x))
1630318146385:(defn divides? [x y] (zero? (mod y x)))
1630318173211:(let [x 15] (condp divides? x\n              15 :fizz-buzz\n              5 :buzz\n              3 :fizz\n              x))
1630318179119:(let [x 5] (condp divides? x\n              15 :fizz-buzz\n              5 :buzz\n              3 :fizz\n              x))
1630318193247:(macroexpand '(condp divides? x\n              15 :fizz-buzz\n              5 :buzz\n              3 :fizz\n              x))
1630318274969:(or 4 5 6)
1630318279449:(macroexpand '(or 4 5 6))
1630344320747:(let [[& x] []] x\n     )
1630344337525:(defn foo [& x] (count x))
1630344340786:(foo)
1630344351283:(count nil)
1630344354555:(count)
1630468221151:(macroexpand '(condp < 5 4 true))
1630468382283:(macroexpand '(condp < 5 4 true 6 7))
1630468522227:(macroexpand '(condp))
1630468533291:(macroexpand '(condp < 5 4))
1630468546890:(macroexpand '(condp < 5 8))
1630468553603:(macroexpand '(condp < 5 8 9))
1630468564803:(macroexpand '(condp < 5 8 9 10))
1630468577835:(macroexpand '(condp < 5 8 9 7 6 10))
1630468779747:(every? even? [])
1630468802707:(some even? [])
1630469307025:(and)
1630469402567:(macroexpand '(-> 2 (+ 4 8) (* 7 9)))
